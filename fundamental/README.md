## 基础课小结

### 上部

#### 头文件的防卫式声明

防止头文件重复包含发生冲突

``` c++
#ifndef __NAME__
#define __NAME__
...
...
#endif 
```

### 类的定义

```c++
class complex
{
public:
	...
private:
    ...
};
```

###  inline内联函数

1. 声明在类内的函数自动成为候选内联函数，是否成为内联函数取决于编译器。
2. 使用inline修饰的函数也会成为候选内联函数，但是否成为内联函数同样取决于编译器。

### 类成员的访问修饰符

1. public的成员可以通过对象调用。
2. private的成员不允许通过对象调用。
3. protected。

### 构造函数

1. 构造函数没有返回值。
2. 构造函数一般是public的，特殊情况下可以是private的（单例模式）。
3. 可以使用初始化值列表对类成员进行初始化，注意它和赋值的区别。
4. 不能同时存在含有默认参数和没有参数的构造函数，在不使用参数新建对象时会发生冲突。

类的构造过程包括**初始化**、**赋值**......

### 常量成员函数

当一个函数不需要修改成员变量时，使用const标记使其成为常量成员函数。

```c++
class complex
{
public:
    ...
    double real() const { return re; }
private:
    ...
}
```

### 友元函数

被friend修饰的函数是友元函数，友元函数是非成员函数但可以访问该类的成员。

相同class的不同object的成员函数互为友元。

### 函数参数传递

1. 按值传递
2. 按引用传递

设计函数时，首先考虑传引用，传引用比传值更快，尤其是传递对象的情况下，传值需要对对象进行拷贝，会花费较多的时间。

### 函数返回值

1. 按值返回
2. 按引用返回

当需要返回的对象是在函数内部生成时，应该按值返回，而不应该按引用返回，因为在函数内部生成的对象，作用域在函数内，在函数结束后，自动调用析构函数进行销毁，其生命周期只在函数内。

在涉及流的引用的函数，返回流的引用可以实现输出连用，如下：

```c++
std::ostream&   //返回流的引用，则可以实现cout << a << b << ... << enl;连用
operator << (std::ostream& os, const complex& rhs)
{
    return os << '(' << real(rhs) << ','
              << imag(rhs) << ')';
}
```



### 操作符重载

1. 成员函数操作符重载

   此类操作符重载函数参数含有隐式的this指针。

   应返回本对象的引用。

2. 非成员函数操作符重载

   该类操作符重载一般会在函数内部生成一个临时对象用作返回值，应按值返回，因为临时对象的生命周期只有在函数内。

   带有流操作的非成员操作符重载，应返回流的引用。

   

### 下部

